{
	"Web Component": {
		"scope": "javascript,typescript",
		"prefix":["web-component", "class"],
		"body": [
			"/**",
			"* $TM_FILENAME_BASE Widget",
			"* @example",
			"* ```html",
			"* <${1:tag-name}></${1:tag-name}>",
			"* ```",
			"* @version 1.0.0",
			"* @author ${2:author}",
			"* @docauthor ${2:author}",
			"* @url $RELATIVE_FILEPATH",
			"* @extends HTMLElement",
			"* @element ${1:tag-name}",
			"*/",
			"class $TM_FILENAME_BASE extends window.HTMLElement {",
			"",

			"\tconstructor () {",
			"\t\t// Always call super first in constructor",
			"\t\tsuper()",
			"\t\t// write element functionality in here",
			"\t\tconst widget = this",
			"\t\twidget.isRendered = false",
			"\t\t// Create a shadow root {@link https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM}",
			"\t\twidget.attachShadow({mode: '${3|open,closed|}'})",
			"\t\t$0",
			"\t}",
			"",

			"\t/**",
			"\t* Invoked each time the custom element is appended into a document-connected element. This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.",
			"\t*/",
			"\tconnectedCallback() {",
			"\t\tconst widget = this",
			"\t\tif (widget.isRendered) return",
			"\t\t// Create elements",
			"\t\t// const elem = document.createElement('div')",
			"\t\t// Create styles",
			"\t\t// const style = document.createElement('style')",
			"\t\t// style.textContent = 'div {}'",
			"\t\t// attach the created elements to the shadow DOM",
			"\t\t// widget.shadowRoot.append(style,wrapper)",
			"\t\twidget.isRendered = true",
			"\t}",
			"",

			"\t/**",
			"\t* Invoked each time the custom element is disconnected from the document's DOM.",
			"\t*/",
			"\tdisconnectedCallback () {",
			"\t\tconst widget = this",
			"\t\tif (widget.isRendered === false) return",
			"\t\t// widget.shadowRoot.innerHTML = ''",
			"\t\twidget.isRendered = false",
			"\t}",
			"",

			"\t/**",
			"\t* The attributeChangedCallback() callback is run whenever one of the element's attributes is changed in some way. As you can see from its properties, it is possible to act on attributes individually, looking at their name, and old and new attribute values.",
			"\t*/",
			"\tattributeChangedCallback (name, oldValue, newValue) {",
			"\t\tconsole.log('Attribute ' + name + ' changed to ' + newValue)",
			"\t}",
			"",
			
			"\t/**",
			"\t* To get the attributeChangedCallback() callback to fire when an attribute changes, you have to observe the attributes. This is done by specifying a static get observedAttributes() method inside custom element class.",
			"\t*/",
			"\tstatic get observedAttributes () {",
			"\t\t// return an array containing the names of the attributes you want to observe",
			"\t\treturn ['disbaled', 'hidden']",
			"\t}",
			"",
			"}",

			"$BLOCK_COMMENT_START Finally, we register our custom element on the CustomElementRegistry using the define() method we mentioned earlier — in the parameters we specify the element name, and then the class name that defines its functionality:$BLOCK_COMMENT_END",
			"window.customElements.define('${1:tag-name}', $TM_FILENAME_BASE)",
			"",
			"$BLOCK_COMMENT_START For easier development and usage in a widget library we will export the class as well.$BLOCK_COMMENT_END",
			"export default $TM_FILENAME_BASE",
			""
		],
		"description": "An autonomous custom elements Web Component with all general functions"
	},
	"Form Web Component": {
		"scope": "javascript,typescript",
		"prefix": [
			"web-component-form",
			"class",
			"form"
		],
		"body": [
			"/**",
			"* $TM_FILENAME_BASE Form Widget",
			"* @example",
			"* ```html",
			"* <${1:tag-name}></${1:tag-name}>",
			"* ```",
			"* @version 1.0.0",
			"* @author ${2:author}",
			"* @docauthor ${2:author}",
			"* @url $RELATIVE_FILEPATH",
			"* @extends HTMLElement",
			"* @element ${1:tag-name}",
			"* @see {@link https://web.dev/more-capable-form-controls/} for further information about designing a Web Component for forms.",
			"*/",
			"class $TM_FILENAME_BASE extends window.HTMLElement {",
			"",
			"\t// Identify the element as a form-associated custom element",
			"\tstatic formAssociated = true",
			"",
			"\tconstructor () {",
			"\t\t// Always call super first in constructor",
			"\t\tsuper()",
			"\t\t// write element functionality in here",
			"\t\tconst widget = this",
			"\t\t// Get access to the internal form control APIs",
			"\t\twidget.internals_ = widget.attachInternals()",
			"\t\t// internal value for this control",
			"\t\twidget.value_ = 0",
			"\t\t// define own properties",
			"\t\twidget.isRendered = false",
			"\t\t// Create a shadow root {@link https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM}",
			"\t\twidget.attachShadow({mode: '${3|open,closed|}'})",
			"\t\t$0",
			"\t}",
			"",

			"\t/**",
			"\t* Invoked each time the custom element is appended into a document-connected element. This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.",
			"\t*/",
			"\tconnectedCallback() {",
			"\t\tconst widget = this",
			"\t\tif (widget.isRendered) return",
			"\t\t// Create elements",
			"\t\t// const elem = document.createElement('div')",
			"\t\t// Create styles",
			"\t\t// const style = document.createElement('style')",
			"\t\t// style.textContent = 'div {}'",
			"\t\t// attach the created elements to the shadow DOM",
			"\t\t// widget.shadowRoot.append(style,wrapper)",
			"\t\twidget.isRendered = true",
			"\t}",
			"",

			"\t/**",
			"\t* Invoked each time the custom element is disconnected from the document's DOM.",
			"\t*/",
			"\tdisconnectedCallback () {",
			"\t\tconst widget = this",
			"\t\tif (widget.isRendered === false) return",
			"\t\t// widget.shadowRoot.innerHTML = ''",
			"\t\twidget.isRendered = false",
			"\t}",
			"",

			"\t// Form controls usually expose a \"value\" property",
			"\tget value() { return this.value_ }",
			"\tset value(v) { this.value_ = v }",
			"",
			"\t$BLOCK_COMMENT_START The following properties and methods aren't strictly required, but browser-level form controls provide them. Providing them helps ensure consistency with browser-provided controls.$BLOCK_COMMENT_END",
			"\tget form() { return this.internals_.form }",
			"\tget name() { return this.getAttribute('name') }",
			"\tget type() { return this.localName }",
			"\tget validity() {return this.internals_.validity }",
			"\tget validationMessage() {return this.internals_.validationMessage }",
			"\tget willValidate() {return this.internals_.willValidate }",
			"\tcheckValidity() { return this.internals_.checkValidity() }",
			"\treportValidity() {return this.internals_.reportValidity() }",
			"",

			"\t/**",
			"\t* The attributeChangedCallback() callback is run whenever one of the element's attributes is changed in some way. As you can see from its properties, it is possible to act on attributes individually, looking at their name, and old and new attribute values.",
			"\t*/",
			"\tattributeChangedCallback (name, oldValue, newValue) {",
			"\t\tconsole.log('Attribute ' + name + ' changed to ' + newValue)",
			"\t}",
			"",
			"\t/**",
			"\t* To get the attributeChangedCallback() callback to fire when an attribute changes, you have to observe the attributes. This is done by specifying a static get observedAttributes() method inside custom element class.",
			"\t*/",
			"\tstatic get observedAttributes () {",
			"\t\t// return an array containing the names of the attributes you want to observe",
			"\t\treturn ['disbaled', 'hidden']",
			"\t}",
			"",
			
			"}",
			"$BLOCK_COMMENT_START Finally, we register our custom element on the CustomElementRegistry using the define() method we mentioned earlier — in the parameters we specify the element name, and then the class name that defines its functionality:$BLOCK_COMMENT_END",
			"window.customElements.define('${1:tag-name}', $TM_FILENAME_BASE)",
			"",
			"$BLOCK_COMMENT_START For easier development and usage in a widget library we will export the class as well.$BLOCK_COMMENT_END",
			"export default $TM_FILENAME_BASE",
			""
		],
		"description": "An autonomous custom elements Web Component for forms with all general functions"
	}
}